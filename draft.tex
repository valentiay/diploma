\documentclass[14pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{extsizes}
\usepackage[english,russian]{babel}
\usepackage{geometry}
\usepackage{tempora}
\usepackage{amsmath}

\geometry{
    a4paper,
    left=30mm,
    top=20mm,
    right=20mm,
    bottom=20mm
}

\linespread{1.5}

\title{Эффективная классификация событий в потоковых системах}
\author{Валентинов Александр}
\date{2020}

\begin{document}
\maketitle
\clearpage
\tableofcontents
\clearpage
\section{Вступление}
[TODO]

\section{Анализ задачи}
\subsection{Определения}
Введем несколько определений, необходимых для формальной постановки задачи.
Ниже будем считать, что количество признаков (длина кортежей) $d$ - это некоторое "небольшое" целое число.
В данной работе считается, что $d$ находится в пределах $[1, 32]$.

\emph{Cобытие} - кортеж длины $d$ из чисел в пределах $[0, 1]$: $X = (x_1,...,x_d), \forall i: x_i \in [0, 1]$.

\emph{Правило} - кортеж длины $d$ из предикатов $P = (p_1,...,p_d), \forall i: p_i(x): [0, 1] \rightarrow \{0, 1\}$, каждый из которых имеет один из видов:
\begin{itemize}
    \item $p_i(x) \equiv 1$;
    \item $ p_i(x) =
        \begin{cases}
        1, & a \leq x \leq b, \\
        0, & a > x \vee x > b.
        \end{cases}
    $ - для некоторых фиксированных $a$ и $b$, $0 \leq a \leq b \leq 1$;
    \item $ p_i(x) =
        \begin{cases}
        1, & a \leq x, \\
        0, & a > x.
        \end{cases}
    $ - для некоторого фиксированного $a$, $0 \leq a \leq 1$;
    \item $ p_i(x) =
        \begin{cases}
        1, & x \leq b, \\
        0, & x > b.
        \end{cases}
    $ - для некоторого фиксированного $b$, $0 \leq b \leq 1$;
    \item $ p_i(x) =
        \begin{cases}
        1, & x = a, \\
        0, & x \neq a.
        \end{cases}
    $ - для некоторого фиксированного $a$, $0 \leq a \leq 1$.
\end{itemize}

\emph{Совпадение} - пара из события и правила, такое что каждый элемент кортежа-события удовлетворяет соответствующему предикату из правила: $(X, P): \prod_{i=1}^d p_i(x_i) = 1$.

\subsection{Постановка задачи}
Дадим формальное определение задачи классификации событий, используя введенные определения.

Имеется поток событий, которые можно читать из некоторой входной очереди сообщений. Также есть набор правил, который хранится в базе данных. Необходимо находить все совпадения между событиями и правилами так, чтобы за единицу времени обрабатывалось как можно больше событий, и записывать результаты в выходную очередь.

Количество событий, появляющихся во входной очереди может быть больше, чем возможно эффективно обработать на одном сервере, поэтому система должна быть горизонтально-масштабируемой. Ориентировочные значения нагрузки - тысячи событий в секунду и десятки тысяч правил.

Набор правил может изменяться, но допускается задержка в обработке изменений правил. Это допущение необходимо для того, чтобы система, решающая задачу, могла строить неизменяемые индексы.

Задача этой работы - спроектировать систему, решающую эту задачу и реализовать ее прототип.

\subsection{Возможные применения и мотивация}
Задача встречается, когда широкому кругу пользователей необходимо выделить интересующие их события из потока бизнес событий. Ниже несколько примеров:
\begin{itemize}
    \item У агрегатора интернет-магазинов есть поток бизнес-событий вида "Товар $A$ марки $B$, с характеристиками $C$, $D$, и $E$, ценой $F$ появился в магазине $G$". Используя систему, решающую задачу классификации событий, пользователь может подписаться на появление какого-то товара, создав правило, с интересующими его параметрами. Пример такого правила - "\emph{Чайник} марки \emph{Panasonic} \emph{зеленого цвета}, ценой от \emph{1000 рублей} появился в \emph{любом} магазине". Нечисловые параметры можно кодировать числами на входе и выходе из системы.
    \item Поисковик авиабилетов записывает в очередь результаты поисков в виде "Билет из аэропорта $A$ в аэропорт $B$, с $C$ пересадками ценой $D$". С помощью системы пользователь может следить за ценами на интересующие его авиабилеты, создав правило, например "Билет из \emph{Пекина} во \emph{Францию} с \emph{не более, чем двумя} пересадками, \emph{не дороже 20000 рублей}". Страну в правиле можно представить как отрезок чисел, а аэропорты - числами в этом отрезке.
\end{itemize}

Главное достоинство такой системы - возможность анализировать события, не сохраняя их на долгое время и не запуская какие-то процессы, которые бы для каждого правила искали подходящие события.

\subsection{Анализ аналогов}
Существующие аналоги для решения задачи классификации можно разбить на две группы: фреймворки для обработки потоковых данных и базы данных, имеющие возможность хранить пространственные данные.

Фреймворки для обработки потоковых данных, среди которых, например Apache Flink, Apache Storm, Apache Samza и другие, больше рассчитаны на подсчет агрегатов \cite{flink-use-cases, storm-documentation, samza-streams-api}, чем на сопоставление событий из потока с правилами. Используя стандартные функции этих фреймворков, возможно реализовать решение этой задачи, но при большом числе правил оно будет не так эффективно, как расмотренное в этой работе. К тому же, многие из таких фреймворков нацелены на offline-обработку, в нашем случае необходима online-обработка событий. Способы решения задачи, которые будут описаны в следующих главах, можно интегрировать с такими фреймворками, но, для упрощения реализации, они не используются.

Базы данных, имеющие возможность работать с пространственными данными - MySQL, PostgreSQL + PostGIS, Oracle Spatial и т.п. позволяют хранить многомерные данные, но они оптимизированы для задач, связанных с обработкой геоданных - двумерных координат на карте Земли \cite{mysql-spatial, postgis, oracle-spatial}. При работе с многомерными данными они либо неприменимы, либо неэффективны.

\section{Архитектура}
\subsection{Архитектура в случае одного сервера}
Раcсмотрим, сначала, возможные варианты архитектуры системы, при наличии всего одного сервера. Разберем наивное решение и несколько вариантов индексов.

\subsubsection{Наивное решение}
В случае наивного решения правила читаются из базы и кешируются на определенное время. После истечения этого времени они снова читаются и кешируются, чтобы получить изменения, которые, возможно, произошли в правилах.

События читаются из входной очереди по одному и сопоставляются с каждым из правил. Если находятся совпадения, они записыватются в выходную очередь по одному. Так как используется линейный поиск, сложность нахождения всех правил для одного события - $O(|P_\alpha|)$, где $|P_\alpha|$ - количество правил. Для $n$ правил сложность составляет $O(n|P_\alpha|)$.

\subsubsection{R-деревья}
Во всех решениях, описанных ниже, используются различные вариации $R$-деревьев \cite{r-tree}. Это специальный вид деревьев, который позволяет индексировать многомерные точки и прямоугольники. Каждый узел $R$-дерева имеет не более максимально допустимого числа детей и хранит ограничивающий прямоугольник для объектов или поддеревьев, которые в нем содержатся. Основная идея работы $R$-дерева состоит в том, что оно разбивает пространство на множество иерархически вложенных многомерных прямоугольников, которые, возможно, пересекаются между собой. Это позволяет группировать "близкие" объекты по узлам и листьям дерева и увеличивает эффективность поиска.

К $R$ - дереву можно делать запросы как на поиск всех прямоугольников, которые содержат заданную точку, так и на поиск всех точек, которые находятся в заданном прямоугольнике. Второй тип запросов работает медленнее, т.к. приходится проверять больше вершин.

Для вставки одного объекта необходимо использовать эвристику, которая определяет, какой узел нужно выбрать для вставки и как, при необходимости, разбить узел. Большинство эвристик хорошо работают только для вставки в случае двумерного пространства.

\paragraph{X-дерево.} Наиболее эффективным вариантом $R$ дерева для работы с многомерными данными является $X$-дерево \cite{x-tree}. Оно использует алгоритм выбора и разбиения основанный на алгоритме $R^*$-дерева \cite{r-star-tree}. При разбиении узла, если эвристика $R^*$-дерева дает результат со слишком большим пересечением ограничивающих прямоугольников, сначала происходит попытка разбить узел, основываясь на истории предыдущих разбиений. Если вторая попытка разбить узел также дает слишком большое пересечение, узел не разбивается, превращаясь в супер-узел с числом детей, большим, чем максимально допустимое. Это позволяет избегать неоптимальных разбиений и уменьшает количество посещаемых поддеревьев поиск более эффективным. Амортизированная сложность вставки в $X$-дерево с $n$ элементами и максимальным числом элементов в узле равном $M$ - $O(\log_M n)$. Вставка $n$ элементов будет иметь сложность $O(n\log_M n)$.

\paragraph{Алгоритм массовой вставки в R-дерево.} Другой способ построить оптимальное $R$-дерево в случае многомерного пространства - алгоритм массовой вставки в $R$-дерево \cite{str, omt}. Он применим, когда заранее известны все объекты, которые нужно вставить в дерево. Алгоритм начинает работу из корня будущего дерева. На каждом шаге рассчитывается, сколько детей будет у узла, который сейчас создается - $s$ (если узел не является корнем, то это число равно максимальному числу детей у узла). Далее все объекты сортируются по началу отрезка ограничивающего прямоугольника в измерении $h\mod d$, где $h$ - глубина создаваемого узла (для корня - 0, для ребенка корня - 1 и т.д.). Потом отсортированный массив объектов разбивается на $s$ групп. Каждая группа - объекты, которые содержатся в одном из поддеревьев корня. Затем алгоритм рекурсивно запускается для каждой из этих групп. В результате получается сбалансированное дерево, в котором ограничивающие прямоугольники слабо пересекаются. В случае, если в дерево записываются только точки, ограничивающие прямоугольники не пересекаются совсем. Сложность построения $R$-дерева алгоритмом массовой вставки - $O(n\log n)$.

Из-за того, что в результате применения этих двух подходов получаются хорошо сбалансированные $R$-деревья, они позволяют достаточно эффективно индексировать как точки, так и многомерные прямогульники. Сложность чтения из сбалансированного $R$-дерева - $O(\log_M n)$, где $M$ - максимальное допустимое число элементов в узле, а $n$ - количество элементов в дереве.

\subsubsection{Подходы к индексированию}
Для задачи классификации можно использовать два способа. Первый способ - индексировать правила и искать в этом индексе точки по одной. Второй - группировать события во входном потоке, строить по группе индекс и искать в этом индексе все правила.

\paragraph{Индексация правил.} При данном подходе одно правило представляется кубом в многомерном пространстве. Предикаты преобразуются в отрезки следующим образом:
\begin{itemize}
    \item $a \leq x \leq b \rightarrow [a ,b]$
    \item $a \leq x \rightarrow [a, 1]$
    \item $x \leq b  \rightarrow [0, b]$
    \item $ x = a \rightarrow [a, a]$
    \item $ x = x \rightarrow [0, 1]$
\end{itemize}
Например, правило $(x_1 \leq 0.1, 0.6 \leq x_2, 0.5 \leq x_3 \leq 0.7, x_4 = 0.2, x_5 = x_5)$ преобразуется в прямоугольник $[0, 0.1]\times[0.6, 1]\times[0.5, 0.7]\times[0.2, 0.2]\times[0, 1]$. Каждое правило можно превратить в прямоугольник и на этих прямоугольниках построить $R$-дерево. Используя алгоритм поиска точки в $R$-дереве из прямоугольников, можно найти все правила, которым удовлетворяет событие. При таком подходе правила хранятся в дереве. События читаются из входной очереди по одному. Для каждого события ищутся все правила, под которые оно подходит. Найденные правила записываются в выходную очередь. Через определенный промежуток времени правила читаются из базы и индекс перестраивается, чтобы учитывать изменения, которые могли произойти в правилах. Сложность поиска одного события в $R$-дереве с $n$ прямоугольниками - $O(\log n)$. Сложность обработки $k$ событий - $O(k \log n)$.

\paragraph{Индексация событий}

\begin{thebibliography}{9}
\bibitem{flink-use-cases}
Apache Flink Use Cases,\\
\texttt{https://flink.apache.org/usecases.html}.

\bibitem{storm-documentation}
Apache Storm Documentation,\\
\texttt{http://storm.apache.org/index.html}

\bibitem{samza-streams-api}
Apache Samza Streams API,\\
\texttt{https://samza.apache.org/learn/documentation/latest/api/\\high-level-api.html}

\bibitem{mysql-spatial}
MySQL Spatial Types,\\
\texttt{https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html}

\bibitem{postgis}
PostGIS Manual,\\
\texttt{https://postgis.net/docs/manual-3.0/}

\bibitem{oracle-spatial}
Oracle Spatial Features,\\
\texttt{https://www.oracle.com/database/technologies/\\spatialandgraph/spatial-features.html}

\bibitem{r-tree}
Antonin Guttman. \textit{R-Trees: A Dynamic Index Structure for Spatial Searching}. Proc. 1984 ACM SIGMOD International Conference on Management of Data: 47–57.

\bibitem{x-tree}
Stefan Berchtold; Daniel A. Keim; Hans-Peter Kriegel. \textit{The X-tree: An Index Structure for High-Dimensional Data}. Proc. 22nd VLDB Conference. Mumbai, India: 28–39.

\bibitem{r-star-tree}
Norbert Beckmann; Hans-Peter Kriegel; Ralf Schneider; Bernhard Seeger. \textit{The R*-tree: an efficient and robust access method for points and rectangles}. Proc. 1990 ACM SIGMOD International Conference on Management of Data: 322-331.

\bibitem{str}
Scott T. Leutenegger; Mario A. Lopez; Jeffrey Edgington. \textit{STR: A Simple and Efficient Algorithm for R-Tree Packing}. Proc. 1997. 13th IEEE Conference on Data Engineering: 495-506.

\bibitem{omt}
Taewon Lee; Sukho Lee. \textit{OMT: Overlap Minimizing Top-down Bulk Loading Algorithm for R-tree}. 2003. CAiSE Short Paper Proceedings.


\end{thebibliography}
\end{document}
